# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Begin: Join Active Directory


# Disable autoamtic node AD Domain Join by enabling local user synchronization using:
# socactl config set --key "/configuration/FeatureFlags/Hpc/JoinEphemeralNodesToAD" --value "false"

# Note: This is an experimental feature
{% if not context.get("/configuration/FeatureFlags/Hpc/JoinEphemeralNodesToAD") and context.get("/job/NodeType") == "compute_node" %}
  function sync_ad_users_locally {
    local LOCAL_SOCA_AD_SCRIPT="/opt/soca/{{ context.get("/configuration/ClusterId") }}/sync_ad_users_locally.sh"
    {% if context.get("/job/JobQueue") == "alwayson" %}
        local USERS_TO_SYNC="" # sync all users in alwayson nodes, please note this can cause some slowness if you have a large number of users
    {% else %}
        local USERS_TO_SYNC="{{ context.get("/job/JobOwner") }}" # Only sync job owner. empty string if you want to sync ALL SOCA users, this may cause some slowness if you have a large number of users.
    {% endif %}
    log_info "Ephemeral HPC Compute Node are now joined to AD, instead, we re-create the SOCA users locally to avoid a AD domain join. User info ${LOCAL_SOCA_AD_USERS}"

    log_info "Writting local SOCA AD script to ${LOCAL_SOCA_AD_SCRIPT}"
    cat > "$LOCAL_SOCA_AD_SCRIPT" <<'EOF'
{% include "templates/linux/user_directory/active_directory/sync_ad_users_locally.sh.j2" %}
EOF

    log_info "Making ${LOCAL_SOCA_AD_SCRIPT} executable"
    chmod +x ${LOCAL_SOCA_AD_SCRIPT}

    log_info "Executing script to sync ${USERS_TO_SYNC} locally ...."
    if ! ${LOCAL_SOCA_AD_SCRIPT} ${USERS_TO_SYNC}; then
        exit_fail "Unable to sync ${USERS_TO_SYNC}  user locally"
    else
        log_info "AD users synced locally, checking /etc/passwd"
        cat /etc/passwd
        log_info "AD users synced locally, checking /etc/group"
        cat /etc/group
    fi

    log_info "configuring ${LOCAL_SOCA_AD_SCRIPT} as recurring cron on the remote machine"
    # delete crontab if already there and create new one
    ( crontab -l 2>/dev/null | grep -v "${LOCAL_SOCA_AD_SCRIPT}"; \
  echo "*/10 * * * * ${LOCAL_SOCA_AD_SCRIPT} ${USERS_TO_SYNC} >> ${SOCA_BOOTSTRAP_LOGS_FOLDER}/sync_ad_users.log 2>&1" \
    ) | crontab -
  }
  sync_ad_users_locally
    

{% else %}
  function join_ad {
    log_info "Trying to join Active Directory ... "

    if ! verify_package_installed adcli; then
      log_info "adcli is not installed, installing it ... "
      packages_install adcli
    fi

    if ! verify_package_installed realmd; then
      log_info "realm is not installed, installing it ... "
      packages_install realmd
    fi

    {% include "templates/linux/patch_krb5.sh.j2" %}

    local DS_DOMAIN_NAME="{{ context.get("/configuration/UserDirectory/domain_name") }}"
    local UPPER_DS_DOMAIN_NAME="{{ context.get("/configuration/UserDirectory/domain_name") | upper }}"
    local SOCA_DIRECTORY_ADMINS_SEARCH_BASE="{{ context.get("/configuration/UserDirectory/admins_search_base") | lower }}"
    local SOCA_DIRECTORY_ADMIN_GROUP_NAME=$(echo ${SOCA_DIRECTORY_ADMINS_SEARCH_BASE} | awk -F'[,=]' '{print $2}')
    local ESCAPED_SOCA_DIRECTORY_ADMIN_GROUP_NAME=$(echo ${SOCA_DIRECTORY_ADMIN_GROUP_NAME} | sed 's/ /\\ /g') # "My Group" will become "My\ Group"
    local SKIP_AD_JOIN="false" # will be changed to True if the AMI is already joined to the domain
    local DS_DOMAIN_ADMIN_USERNAME
    local DS_DOMAIN_ADMIN_PASSWORD
    local ADCLI=$(command -v adcli)
    local REALM=$(command -v realm)
    local AWS_INSTANCE_ID=$(instance_id)

    log_info "Active Directory Domain Name: ${DS_DOMAIN_NAME}"

    log_info "Verifying if  AD is reachable from the node"
    local LOOP_VERIFY_AD_REACHABILITY=0
    while ! ${REALM} discover "$DS_DOMAIN_NAME" && [[ ${LOOP_VERIFY_AD_REACHABILITY} -lt 30 ]]
      do
        ((LOOP_VERIFY_AD_REACHABILITY++))
        log_info "${DS_DOMAIN_NAME} is not reachable from this host. If using AWS Directory Service, waiting for Route 53 outbound endpoint and rule to become active. Trying again in 2 minutes. Loop count is: ${LOOP_VERIFY_AD_REACHABILITY}/10"
        sleep 180
      done
    log_info "${DS_DOMAIN_NAME} is reachable"

    # Create cached location if needed. This location is restricted to admin user only
    local AD_AUTOMATION_CACHED_LOCATION="/apps/soca/{{ context.get("/configuration/ClusterId") }}/shared/custom_automation/ad_automation"
    local AD_AUTOMATION_CACHED_USERNAME_LOCATION="${AD_AUTOMATION_CACHED_LOCATION}/join_domain_user.cache"
    local AD_AUTOMATION_CACHED_PASSWORD_LOCATION="${AD_AUTOMATION_CACHED_LOCATION}/join_domain.cache"
    log_info "AD Cached Location is ${AD_AUTOMATION_CACHED_LOCATION}"
    # Retrieve account with join permission if available, otherwise query SecretManager
    # to migrate to AD OTP
    {% if context.get("/job/NodeType") == "controller" %}
      mkdir -p ${AD_AUTOMATION_CACHED_LOCATION}
      chmod 600 ${AD_AUTOMATION_CACHED_LOCATION}
      log_info "Querying SecretsManager API to retrieve AD Service Account"
      local DS_DOMAIN_ADMIN_CREDENTIALS=$(get_secret "{{ context.get("/configuration/UserDirectory/service_account_secret_arn") }}")
      if [[ -z ${DS_DOMAIN_ADMIN_CREDENTIALS} ]]; then
        exit_fail "DS_DOMAIN_ADMIN_CREDENTIALS is empty, unable to get secret info from {{ context.get("/configuration/UserDirectory/service_account_secret_arn") }}"
      fi
      local DS_DOMAIN_ADMIN_USERNAME=$(echo ${DS_DOMAIN_ADMIN_CREDENTIALS} | jq -r ". | fromjson.username")
      local DS_DOMAIN_ADMIN_PASSWORD=$(echo ${DS_DOMAIN_ADMIN_CREDENTIALS} | jq -r ". | fromjson.password")
      echo -n "${DS_DOMAIN_ADMIN_USERNAME}" > ${AD_AUTOMATION_CACHED_USERNAME_LOCATION}
      echo -n "${DS_DOMAIN_ADMIN_PASSWORD}" > ${AD_AUTOMATION_CACHED_PASSWORD_LOCATION}
      chmod 600 ${AD_AUTOMATION_CACHED_USERNAME_LOCATION}
      chmod 600 ${AD_AUTOMATION_CACHED_PASSWORD_LOCATION}
      log_info "AD Domain User cached on filesystem via ${AD_AUTOMATION_CACHED_LOCATION}"
    {% else %}
      log_info "Non SOCA controller host, fetching AD Service Account via ${AD_AUTOMATION_CACHED_LOCATION}"
      {% if context.get("/job/NodeType") == "login_node" %}
      # first login node is deployed at the same time of the controller, so to avoid race conditions, we add some sleep to ensure the controller has finalized the AD setup
      # as it's the only machine with an IAM role which allow querying Secrets Manager
      local RETRY_COUNT=0
      while [[ ! -f "${AD_AUTOMATION_CACHED_USERNAME_LOCATION}" ]] || [[ ! -f "${AD_AUTOMATION_CACHED_PASSWORD_LOCATION}" ]]; do
        if [[ ${RETRY_COUNT} -ge 30 ]]; then
            exit_fail "AD Service Account did not appear after 15 minutes. Verify SOCA Controller."
        fi
        log_info "${AD_AUTOMATION_CACHED_USERNAME_LOCATION} or ${AD_AUTOMATION_CACHED_PASSWORD_LOCATION} don't exist, waiting for SOCA controller, trying again in 30 seconds"
        sleep 60
        ((RETRY_COUNT++))
      done
      {% else %}
      # compute node - we expect the cache info to be already there.
      if [[ ! -f "${AD_AUTOMATION_CACHED_USERNAME_LOCATION}" ]] || [[ ! -f "${AD_AUTOMATION_CACHED_PASSWORD_LOCATION}" ]]; then
        exit_fail "${AD_AUTOMATION_CACHED_USERNAME_LOCATION} or ${AD_AUTOMATION_CACHED_PASSWORD_LOCATION} don't exist"
      fi
      {% endif %}

      DS_DOMAIN_ADMIN_USERNAME=$(cat "${AD_AUTOMATION_CACHED_USERNAME_LOCATION}")
      DS_DOMAIN_ADMIN_PASSWORD=$(cat "${AD_AUTOMATION_CACHED_PASSWORD_LOCATION}")
    {% endif %}

    # Handle AD case where Service Account is <User>@<Domain>, realm command prefer that we only specify the <User> as the domain is passed as arg
    DS_DOMAIN_ADMIN_USERNAME=$(echo "${DS_DOMAIN_ADMIN_USERNAME}" | awk -F '@' '{print $1}')

    # As hosts are recycled, we ensure we register them to AD with unique and random identifier (15 chars max)
    # Name include SOCA information, which can then easily be decipher by AD admins if/when they want to determine what hosts registered on their AD are SOCA related
    log_info "Generating unique & random 15 char SERVER name to be registered to AD"
    local HOSTNAME_DATA=$(echo "${SOCA_CLUSTER_ID}-${AWS_REGION}-${AWS_INSTANCE_ID}"  | openssl dgst -sha1 -binary | xxd -p | awk '{split($0,h,"."); print toupper(h[1])}')
    local HOSTNAME_PREFIX="SOCA-"
    {{ 'AVAILABLE_CHAR=$((15 - ${#HOSTNAME_PREFIX}))' }} # Jinja2 Escape otherwise $ { # HOSTNAME_PREFIX will return an J2 error
    SHAKE_VALUE=${HOSTNAME_DATA: -${AVAILABLE_CHAR}}
    SOCA_AD_HOSTNAME="${HOSTNAME_PREFIX}${SHAKE_VALUE}"
    
    #Note: When using a small CIDR range where IPs are frequently reused, you may encounter an issue where new EC2 instances cannot join the domain because the recycled IP is still tied to an existing AD computer object.
    #You may see errors such as:

    #Insufficient permissions to modify computer account: CN=SOCA-B073E31845,OU=Computers,OU=redacted,DC=redacted,DC=local:
    # 000021C7: AtrErr: DSID-03200E81, #1:
    # 0: 000021C7: DSID-03200E81, problem 1005 (CONSTRAINT_ATT_TYPE), data 0, Att 90303 (servicePrincipalName)

    #adcli: joining domain redacted.local failed: Insufficient permissions to modify computer account:
    #CN=SOCA-B073E31845,OU=Computers,OU=redacted,DC=redacted,DC=local:
    # 000021C7: AtrErr: DSID-03200E81, #1:
    # 0: 000021C7: DSID-03200E81, problem 1005 (CONSTRAINT_ATT_TYPE), data 0, Att 90303 (servicePrincipalName)
    
    # SOCA attempts to create a new AD object using a randomized hostname.
    # Because of this, granting UPDATE permissions to the service account does not resolve the issueâ€”the existing AD object associated with the IP uses a different name.
    # To prevent this, configure SOCA_AD_HOSTNAME to disable hostname randomization and use a deterministic naming pattern instead. This ensures that when an IP is reused, the AD object name remains consistent and the update permissions apply correctly.
    # Uncomment the line below to enable this behavior: the AD Object will be the SC-<private-ip>, example SC-133010119. Name will never be more than 15 chars.
    
    # SOCA_AD_HOSTNAME=$(hostname -I | tr -d '.-' | tr -d ':-' | tr '[:lower:]' '[:upper:]' | tail -c 15 | sed 's/^/SC-/')

    # Check if host is not already joined to AD
    if ${REALM} list | grep -q "configured: kerberos-member"; then
      log_info "This machine is already joined to AD, checking if it's the correct domain."
      local DOMAIN_ALREADY_JOINED=$(${REALM} list | grep 'domain-name' | awk '{print $2}')
      if [[ "${DOMAIN_ALREADY_JOINED}" == "${DS_DOMAIN_NAME}" ]]; then
        log_info "Host is already joined to ${DS_DOMAIN_NAME}."
        SKIP_AD_JOIN="true"
      else
        log_info "Host is joined to another domain ${DOMAIN_ALREADY_JOINED}, running realm leave"
        echo "${DS_DOMAIN_ADMIN_PASSWORD}" | ${ADCLI} delete-computer -U "${DS_DOMAIN_ADMIN_USERNAME}" --stdin-password --domain="${DOMAIN_ALREADY_JOINED}"
        echo "${DS_DOMAIN_ADMIN_PASSWORD}" | ${REALM} leave --user "${DS_DOMAIN_ADMIN_USERNAME}" "$(echo "${DOMAIN_ALREADY_JOINED}" | tr '[:lower:]' '[:upper:]')" --verbose
      fi
    fi

    # Join AD only if system is not already joined
    if [[ "${SKIP_AD_JOIN}" == "false" ]]; then
      local JOIN_AD_ATTEMPT=0
      log_info "Trying to join host to AD as ${SOCA_AD_HOSTNAME}"
      while ! echo "${DS_DOMAIN_ADMIN_PASSWORD}" | ${REALM} join --user "${DS_DOMAIN_ADMIN_USERNAME}" "${UPPER_DS_DOMAIN_NAME}" --computer-name="${SOCA_AD_HOSTNAME}" --verbose
      do
        ((JOIN_AD_ATTEMPT++))
        local SLEEP_TIME=$(( RANDOM % 60 ))
        log_info "Realm join didn't complete successfully. Retrying in ${SLEEP_TIME} seconds... Loop count is: ${JOIN_AD_ATTEMPT}/10"
        sleep ${SLEEP_TIME}
        echo "${DS_DOMAIN_ADMIN_PASSWORD}" | ${ADCLI} delete-computer -U "${DS_DOMAIN_ADMIN_USERNAME}" --stdin-password --domain="${DS_DOMAIN_NAME}" "${SOCA_AD_HOSTNAME}"
        echo "${DS_DOMAIN_ADMIN_PASSWORD}" | ${REALM} leave --user "${DS_DOMAIN_ADMIN_USERNAME}" "${UPPER_DS_DOMAIN_NAME}" --verbose
        if [[ ${JOIN_AD_ATTEMPT} -eq 10 ]]; then
          exit_fail "Unable to join domain after 10 attempts"
        fi
      done
    fi

    log_info "Joined realm ${DS_DOMAIN_NAME} successfully"
    log_info "Adding AD Admin Group Name to sudoers"
    echo -e "
  ## Add the \"${SOCA_DIRECTORY_ADMIN_GROUP_NAME}\" group from the ${DS_DOMAIN_NAME} domain.
  %${ESCAPED_SOCA_DIRECTORY_ADMIN_GROUP_NAME} ALL=(ALL:ALL) ALL
  " >> /etc/sudoers

    log_info "Configuring SSSD to work with AD"
    cp /etc/sssd/sssd.conf /etc/sssd/sssd.conf.original.$(date +%s)
    echo -e "[sssd]
domains = ${DS_DOMAIN_NAME}
config_file_version = 2
services = nss, pam, sudo

[domain/${DS_DOMAIN_NAME}]
access_provider = ad
ad_domain = ${DS_DOMAIN_NAME}
auth_provider = ad
cache_credentials = True
default_shell = /bin/bash
entry_cache_timeout = 500
fallback_homedir = /data/home/%u
id_provider = ad
krb5_realm = ${UPPER_DS_DOMAIN_NAME}
krb5_store_password_if_offline = True
ldap_id_mapping = False
ldap_sasl_authid = ${SOCA_AD_HOSTNAME}$
ldap_schema = ad
ldap_sudo_search_base = ${SOCA_DIRECTORY_ADMINS_SEARCH_BASE}
ldap_tls_reqcert = never
realmd_tags = manages-system joined-with-adcli
use_fully_qualified_names = False
{% if context.get('/job/NodeType') == "dcv_node" %}ad_gpo_map_interactive = +dcv{% endif %}

[nss]
homedir_substring = /data/home

[pam]

[autofs]

[ssh]" > /etc/sssd/sssd.conf

      chmod 600 /etc/sssd/sssd.conf
      systemctl enable sssd
      systemctl restart sssd
      echo "sudoers: files sss" >> /etc/nsswitch.conf
  }
  join_ad
{% endif %}
# End: Join Active Directory