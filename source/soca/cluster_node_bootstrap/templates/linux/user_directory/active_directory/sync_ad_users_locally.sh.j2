#!/bin/bash

# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# This script runs via cron on compute nodes when /configuration/FeatureFlags/Hpc/JoinEphemeralNodesToAD is set to False.
# In this mode, ephemeral nodes are not joined to Active Directory.
# Instead, the script reads the users_info.json file generated by `socactl ad export`
# and creates the corresponding users and groups locally, preserving the assigned UID and GID values.
# Output is available on /apps/soca/{{ context.get("/configuration/ClusterId") }}/shared/logs/boootstrap/<job_id>/..../sync_ad_users.log

# No argument => sync all SOCA users, otherwise pass a CSV list of user to sync


# Print current date at the beginning of each log
date

# usermod is usually under /usr/sbin which is not part of the default cron PATH
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:$PATH

LOCAL_SOCA_AD_USERS_FILE="/apps/soca/{{ context.get("/configuration/ClusterId") }}/shared/active_directory/sync/users_info.json"

# Optional CSV list of usernames to sync as first argument
FILTER_LIST="$1"

# Check if file exists
if [[ ! -f "${LOCAL_SOCA_AD_USERS_FILE}" ]]; then
    echo "Error: ${LOCAL_SOCA_AD_USERS_FILE} does not exist." >&2
    exit 1
fi

# Validate JSON syntax
if ! jq empty "${LOCAL_SOCA_AD_USERS_FILE}" 2>/dev/null; then
    echo "Error: Invalid JSON syntax on ${LOCAL_SOCA_AD_USERS_FILE}" >&2
    exit 1
fi

# Validate structure
IS_JSON_VALID=$(jq '
    .users
    and (type=="object" or type=="array" or type=="object")
    and (.users | type=="array" and length > 0)
    and (all(.users[];
        has("username") and (.username | type=="string") and
        has("uid") and (.uid | type=="string" or type=="number") and
        has("gid") and (.gid | type=="string" or type=="number") and
        has("comment") and (.comment | type=="string") and
        has("home") and (.home | type=="string") and
        has("shell") and (.shell | type=="string") and
        has("groups") and (.groups | type=="array") and
        all(.groups[]?;
            has("name") and (.name | type=="string") and
            has("gid") and (.gid | type=="string" or type=="number")
        )
    ))
' "${LOCAL_SOCA_AD_USERS_FILE}")

if [[ "${IS_JSON_VALID}" != "true" ]]; then
    echo "Error: ${LOCAL_SOCA_AD_USERS_FILE} does not match expected schema" >&2
    exit 1
fi

# Filter users if a list is provided
if [[ -n "$FILTER_LIST" ]]; then
    echo "Filtering users list: $FILTER_LIST"
    TMP_FILTERED_JSON="/opt/soca/{{ context.get("/configuration/ClusterId") }}/ad_filtered_users.json"
    jq --arg filter "$FILTER_LIST" '
        ($filter | split(",")) as $users_to_keep
        | .users |= map(select(.username as $u | $users_to_keep | index($u)))
    ' "${LOCAL_SOCA_AD_USERS_FILE}" > "$TMP_FILTERED_JSON"
    FILTERED_USERS_SYNC="$TMP_FILTERED_JSON"
else
    echo "No filter provided â€” using all users from ${LOCAL_SOCA_AD_USERS_FILE}"
    FILTERED_USERS_SYNC="${LOCAL_SOCA_AD_USERS_FILE}"
fi

echo "${LOCAL_SOCA_AD_USERS_FILE} is valid."

echo "Creating all groups ..."
jq -r '
  [.users[].groups[]? | {name: .name, gid: .gid}]
  | unique_by(.name)
  | .[] | [.name, .gid] | @tsv
' "${FILTERED_USERS_SYNC}" | while IFS=$'\t' read -r group_name group_gid; do
    if getent group "${group_name}" >/dev/null; then
        existing_gid=$(getent group "${group_name}" | cut -d: -f3)
        if [[ "${existing_gid}" -ne "${group_gid}" ]]; then
            echo "Warning: group ${group_name} exists with GID ${existing_gid} but SOCA requests ${group_gid}"
        fi
    else
        echo "Creating group ${group_name} with GID ${group_gid} ..."
        groupadd -g "${group_gid}" "${group_name}"
    fi
done

echo "Creating all users ..."
jq -r '
  .users[]
  | [
      .username,
      .uid,
      .gid,
      (.comment // ""),
      .home,
      .shell,
      (.groups[].name? // empty)
    ]
  | [
      .[0],
      .[1],
      .[2],
      .[3],
      .[4],
      .[5],
      (.[6:] | map(select(. != "")) | join(","))
    ]
  | @tsv
' "${FILTERED_USERS_SYNC}" |
while IFS=$'\t' read -r username uid gid comment home shell groups_csv; do

    if id "$username" &>/dev/null; then
        echo "User $username already exists, skipping."
    else
        echo "Creating user $username..."
        if useradd -u "$uid" -g "$gid" -c "$comment" -d "$home" --no-create-home -s "$shell" "$username"; then
            echo "User ${username} created successfully"
        else
            echo "Unable to create ${username}"
            exit 1
        fi
    fi

    IFS=',' read -r -a desired_groups <<< "$groups_csv"
    current_groups=$(id -nG "$username" 2>/dev/null | tr ' ' '\n' | grep -v "^$(id -gn "$username")$" || true)

    for g in "${desired_groups[@]}"; do
        [[ -z "$g" ]] && continue
        if ! getent group "$g" &>/dev/null; then
            echo "Creating group $g..."
            groupadd "$g"
        fi
        if ! echo "$current_groups" | grep -qx "$g"; then
            echo "Adding $username to $g..."
            usermod -aG "$g" "$username"
        fi
    done

    for g in $current_groups; do
        if [[ ! " ${desired_groups[*]} " =~ " $g " ]]; then
            echo "Removing $username from $g..."
            gpasswd -d "$username" "$g" >/dev/null
        fi
    done

done

# Cleanup temp file if we used filtering
if [[ -n "$FILTER_LIST" && -f "$TMP_FILTERED_JSON" ]]; then
    rm -f "$TMP_FILTERED_JSON"
fi
